// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package wire

import (
	"context"
	"github.com/google/wire"
	"z-novel-ai-api/internal/config"
	"z-novel-ai-api/internal/domain/repository"
	"z-novel-ai-api/internal/infrastructure/messaging"
	"z-novel-ai-api/internal/infrastructure/persistence/milvus"
	"z-novel-ai-api/internal/infrastructure/persistence/postgres"
	"z-novel-ai-api/internal/infrastructure/persistence/redis"
	"z-novel-ai-api/internal/interfaces/http/handler"
	"z-novel-ai-api/internal/interfaces/http/middleware"
	"z-novel-ai-api/internal/interfaces/http/router"
)

// Injectors from wire.go:

// InitializeDataLayer 初始化数据层
func InitializeDataLayer(ctx context.Context, cfg *config.Config) (*DataLayer, func(), error) {
	client, cleanup, err := ProvidePostgresClient(cfg)
	if err != nil {
		return nil, nil, err
	}
	txManager := postgres.NewTxManager(client)
	tenantContext := postgres.NewTenantContext(client)
	tenantRepository := postgres.NewTenantRepository(client)
	userRepository := postgres.NewUserRepository(client)
	projectRepository := postgres.NewProjectRepository(client)
	volumeRepository := postgres.NewVolumeRepository(client)
	chapterRepository := postgres.NewChapterRepository(client)
	entityRepository := postgres.NewEntityRepository(client)
	relationRepository := postgres.NewRelationRepository(client)
	eventRepository := postgres.NewEventRepository(client)
	jobRepository := postgres.NewJobRepository(client)
	redisClient, cleanup2, err := ProvideRedisClient(cfg)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	cache := redis.NewCache(redisClient)
	rateLimiter := redis.NewRateLimiter(redisClient)
	producer := ProvideMessagingProducer(redisClient, cfg)
	milvusClient, cleanup3, err := ProvideMilvusClient(ctx, cfg)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	repository := milvus.NewRepository(milvusClient)
	dataLayer := &DataLayer{
		PgClient:      client,
		TxManager:     txManager,
		TenantContext: tenantContext,
		TenantRepo:    tenantRepository,
		UserRepo:      userRepository,
		ProjectRepo:   projectRepository,
		VolumeRepo:    volumeRepository,
		ChapterRepo:   chapterRepository,
		EntityRepo:    entityRepository,
		RelationRepo:  relationRepository,
		EventRepo:     eventRepository,
		JobRepo:       jobRepository,
		RedisClient:   redisClient,
		Cache:         cache,
		RateLimiter:   rateLimiter,
		Producer:      producer,
		MilvusClient:  milvusClient,
		VectorRepo:    repository,
	}
	return dataLayer, func() {
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

// InitializeApp 初始化整个应用（带路由器）
func InitializeApp(ctx context.Context, cfg *config.Config) (*router.Router, func(), error) {
	authConfig := ProvideAuthConfig(cfg)
	client, cleanup, err := ProvidePostgresClient(cfg)
	if err != nil {
		return nil, nil, err
	}
	userRepository := postgres.NewUserRepository(client)
	tenantRepository := postgres.NewTenantRepository(client)
	authHandler := handler.NewAuthHandler(authConfig, userRepository, tenantRepository)
	healthHandler := handler.NewHealthHandler()
	projectRepository := postgres.NewProjectRepository(client)
	projectHandler := handler.NewProjectHandler(projectRepository)
	volumeRepository := postgres.NewVolumeRepository(client)
	volumeHandler := handler.NewVolumeHandler(volumeRepository)
	chapterRepository := postgres.NewChapterRepository(client)
	jobRepository := postgres.NewJobRepository(client)
	redisClient, cleanup2, err := ProvideRedisClient(cfg)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	producer := ProvideMessagingProducer(redisClient, cfg)
	chapterHandler := handler.NewChapterHandler(chapterRepository, projectRepository, jobRepository, producer)
	entityRepository := postgres.NewEntityRepository(client)
	relationRepository := postgres.NewRelationRepository(client)
	entityHandler := handler.NewEntityHandler(entityRepository, relationRepository)
	jobHandler := handler.NewJobHandler(jobRepository)
	retrievalGRPCConn, cleanup3, err := ProvideRetrievalGRPCConn(ctx, cfg)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	retrievalServiceClient := ProvideRetrievalGRPCClient(retrievalGRPCConn)
	retrievalHandler := handler.NewRetrievalHandler(retrievalServiceClient)
	txManager := postgres.NewTxManager(client)
	tenantContext := postgres.NewTenantContext(client)
	storyGenGRPCConn, cleanup4, err := ProvideStoryGenGRPCConn(ctx, cfg)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	storyGenServiceClient := ProvideStoryGenGRPCClient(storyGenGRPCConn)
	streamHandler := handler.NewStreamHandler(chapterRepository, txManager, tenantContext, storyGenServiceClient)
	userHandler := handler.NewUserHandler(userRepository)
	tenantHandler := handler.NewTenantHandler(tenantRepository)
	eventRepository := postgres.NewEventRepository(client)
	eventHandler := handler.NewEventHandler(eventRepository)
	relationHandler := handler.NewRelationHandler(relationRepository)
	rateLimiter := redis.NewRateLimiter(redisClient)
	routerHandlers := &router.RouterHandlers{
		Auth:         authHandler,
		Health:       healthHandler,
		Project:      projectHandler,
		Volume:       volumeHandler,
		Chapter:      chapterHandler,
		Entity:       entityHandler,
		Job:          jobHandler,
		Retrieval:    retrievalHandler,
		Stream:       streamHandler,
		User:         userHandler,
		Tenant:       tenantHandler,
		Event:        eventHandler,
		Relation:     relationHandler,
		RateLimiter:  rateLimiter,
		Transactor:   txManager,
		TenantCtxMgr: tenantContext,
	}
	routerRouter := router.NewWithDeps(cfg, routerHandlers)
	return routerRouter, func() {
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

// wire.go:

// DataLayer 数据层依赖容器
type DataLayer struct {
	// PostgreSQL
	PgClient      *postgres.Client
	TxManager     *postgres.TxManager
	TenantContext *postgres.TenantContext
	TenantRepo    *postgres.TenantRepository
	UserRepo      *postgres.UserRepository
	ProjectRepo   *postgres.ProjectRepository
	VolumeRepo    *postgres.VolumeRepository
	ChapterRepo   *postgres.ChapterRepository
	EntityRepo    *postgres.EntityRepository
	RelationRepo  *postgres.RelationRepository
	EventRepo     *postgres.EventRepository
	JobRepo       *postgres.JobRepository

	// Redis
	RedisClient *redis.Client
	Cache       *redis.Cache
	RateLimiter *redis.RateLimiter

	// Messaging
	Producer *messaging.Producer

	// Milvus
	MilvusClient *milvus.Client
	VectorRepo   *milvus.Repository
}

// PostgresSet PostgreSQL 提供者集合
var PostgresSet = wire.NewSet(
	ProvidePostgresClient, postgres.NewTxManager, postgres.NewTenantContext, postgres.NewTenantRepository, postgres.NewUserRepository, postgres.NewProjectRepository, postgres.NewVolumeRepository, postgres.NewChapterRepository, postgres.NewEntityRepository, postgres.NewRelationRepository, postgres.NewEventRepository, postgres.NewJobRepository,
)

// RedisSet Redis 提供者集合
var RedisSet = wire.NewSet(
	ProvideRedisClient, redis.NewCache, redis.NewRateLimiter, wire.Bind(new(middleware.RateLimiter), new(*redis.RateLimiter)),
)

// MessagingSet 消息队列提供者集合
var MessagingSet = wire.NewSet(
	ProvideMessagingProducer,
)

// MilvusSet Milvus 提供者集合
var MilvusSet = wire.NewSet(
	ProvideMilvusClient, milvus.NewRepository,
)

// GRPCClientsSet gRPC 客户端提供者集合
var GRPCClientsSet = wire.NewSet(
	ProvideRetrievalGRPCConn,
	ProvideRetrievalGRPCClient,
	ProvideStoryGenGRPCConn,
	ProvideStoryGenGRPCClient,
	ProvideMemoryGRPCConn,
	ProvideMemoryGRPCClient,
	ProvideValidatorGRPCConn,
	ProvideValidatorGRPCClient,
)

// RouterSet 路由器提供者集合
var RouterSet = wire.NewSet(
	ProvideAuthConfig, handler.NewAuthHandler, handler.NewHealthHandler, handler.NewProjectHandler, handler.NewVolumeHandler, handler.NewChapterHandler, handler.NewEntityHandler, handler.NewJobHandler, handler.NewRetrievalHandler, handler.NewStreamHandler, handler.NewUserHandler, handler.NewTenantHandler, handler.NewEventHandler, handler.NewRelationHandler, wire.Struct(new(router.RouterHandlers), "*"), router.NewWithDeps,
)

// RepoSet 整合了具体实现与接口绑定的集合
var RepoSet = wire.NewSet(
	PostgresSet, wire.Bind(new(repository.Transactor), new(*postgres.TxManager)), wire.Bind(new(repository.TenantContextManager), new(*postgres.TenantContext)), wire.Bind(new(repository.TenantRepository), new(*postgres.TenantRepository)), wire.Bind(new(repository.UserRepository), new(*postgres.UserRepository)), wire.Bind(new(repository.ProjectRepository), new(*postgres.ProjectRepository)), wire.Bind(new(repository.VolumeRepository), new(*postgres.VolumeRepository)), wire.Bind(new(repository.ChapterRepository), new(*postgres.ChapterRepository)), wire.Bind(new(repository.EntityRepository), new(*postgres.EntityRepository)), wire.Bind(new(repository.RelationRepository), new(*postgres.RelationRepository)), wire.Bind(new(repository.JobRepository), new(*postgres.JobRepository)), wire.Bind(new(repository.EventRepository), new(*postgres.EventRepository)),
)

// ProvidePostgresClient 提供 PostgreSQL 客户端
func ProvidePostgresClient(cfg *config.Config) (*postgres.Client, func(), error) {
	client, err := postgres.NewClient(&cfg.Database.Postgres)
	if err != nil {
		return nil, nil, err
	}
	cleanup := func() {
		client.Close()
	}
	return client, cleanup, nil
}

// ProvideRedisClient 提供 Redis 客户端
func ProvideRedisClient(cfg *config.Config) (*redis.Client, func(), error) {
	client, err := redis.NewClient(&cfg.Cache.Redis)
	if err != nil {
		return nil, nil, err
	}
	cleanup := func() {
		client.Close()
	}
	return client, cleanup, nil
}

// ProvideMessagingProducer 提供消息生产者
func ProvideMessagingProducer(redisClient *redis.Client, cfg *config.Config) *messaging.Producer {
	maxLen := cfg.Messaging.RedisStream.MaxLen
	if maxLen <= 0 {
		maxLen = 100000
	}
	return messaging.NewProducer(redisClient.Redis(), int64(maxLen))
}

// ProvideMilvusClient 提供 Milvus 客户端
func ProvideMilvusClient(ctx context.Context, cfg *config.Config) (*milvus.Client, func(), error) {
	client, err := milvus.NewClient(ctx, &cfg.Database.Milvus)
	if err != nil {
		return nil, nil, err
	}
	cleanup := func() {
		client.Close()
	}
	return client, cleanup, nil
}

// ProvideAuthConfig 提供认证配置
func ProvideAuthConfig(cfg *config.Config) middleware.AuthConfig {
	return middleware.AuthConfig{
		Secret:    cfg.Security.JWT.Secret,
		Issuer:    cfg.Security.JWT.Issuer,
		SkipPaths: middleware.DefaultSkipPaths,
		Enabled:   true,
	}
}
