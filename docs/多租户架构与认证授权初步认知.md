# 多租户架构、双 Token 认证与 RBAC 权限控制初步认知

> 从零开始理解多租户隔离、安全认证与权限管理

## 引言

我在 vibe coding 一个复杂系统时，AI 在我的系统中加入了多租户架构、双 Token 认证和 RBAC 权限控制三个核心安全模块，由于我只在小项目中做过简单的单租户认证，并不清楚这些企业级的安全机制，所以写下这篇文章来记录我对多租户架构、双 Token 认证与 RBAC 权限控制的初步认知。

## 核心概念概述

企业级系统的安全性由三个核心支柱组成：

```mermaid
graph LR
    A[系统安全] --> B[多租户架构 Multi-Tenancy]
    A --> C[双 Token 认证 Dual-Token Auth]
    A --> D[RBAC 权限控制 RBAC]

    B --> E[数据隔离]
    C --> F[身份认证]
    D --> G[访问控制]
```

### 酒店管理类比

为了更好理解，我让 AI 用一个连锁酒店来类比：

| 概念       | 酒店场景                                   | 后端系统                                       |
| ---------- | ------------------------------------------ | ---------------------------------------------- |
| **多租户** | 酒店品牌下有多个独立分店（上海店、北京店） | 租户 A、租户 B 共享数据库但数据隔离            |
| **认证**   | 房卡（短期）+ 会员卡（长期）               | Access Token（15 分钟）+ Refresh Token（7 天） |
| **权限**   | 经理可查看所有房间，保洁员只能打扫指定楼层 | Admin 可访问管理接口，Viewer 只读              |

---

## 一、多租户架构 (Multi-Tenancy)

### 1.1 为什么需要多租户？

传统的单租户应用：

```sql
-- 单租户：所有客户共享同一套数据表
SELECT * FROM users WHERE email = 'test@example.com';
```

问题：

- 数据无法隔离：客户 A 可能看到客户 B 的数据
- 运维成本高：每个客户需要独立部署一套系统
- 资源浪费：独立的数据库和服务器资源利用率低

多租户架构（Shared Database, Shared Schema）：

```sql
-- 多租户：同一张表，通过 tenant_id 区分
SELECT * FROM users
WHERE tenant_id = 'tenant_abc'
AND email = 'test@example.com';
```

### 1.2 数据隔离策略

三种常见的多租户隔离策略：

| 策略                        | 优点                 | 缺点                         | 适用场景              |
| --------------------------- | -------------------- | ---------------------------- | --------------------- |
| **独立数据库**              | 最强隔离、性能最好   | 成本高、运维复杂             | 大客户、高合规要求    |
| **共享数据库、独立 Schema** | 隔离性较好、资源共享 | 仍需维护多个 Schema          | 中等规模客户          |
| **共享数据库、共享 Schema** | 最低成本、最易运维   | 依赖应用层隔离，安全风险较高 | SaaS 应用、大量小客户 |

**本系统采用**：共享数据库、共享 Schema + PostgreSQL RLS（Row-Level Security）

### 1.3 PostgreSQL RLS 实现

RLS（Row-Level Security）是 PostgreSQL 提供的数据库级别的行级安全策略，可以在数据层面强制执行租户隔离。

#### RLS 核心概念

```sql
-- 1. 设置当前租户 ID 的函数
CREATE OR REPLACE FUNCTION set_tenant_id(tenant UUID) RETURNS VOID AS $$
BEGIN
    -- is_local=TRUE 表示租户 ID 仅在当前事务内有效
    PERFORM set_config('app.current_tenant_id', tenant::TEXT, TRUE);
END;
$$ LANGUAGE plpgsql;

-- 2. 获取当前租户 ID 的函数
CREATE OR REPLACE FUNCTION current_tenant_id() RETURNS UUID AS $$
BEGIN
    RETURN NULLIF(current_setting('app.current_tenant_id', TRUE), '')::UUID;
END;
$$ LANGUAGE plpgsql;

-- 3. 为表启用 RLS
ALTER TABLE projects ENABLE ROW LEVEL SECURITY;

-- 4. 创建隔离策略
CREATE POLICY tenant_isolation_select ON projects FOR
SELECT USING (
    tenant_id = current_tenant_id()
);
```

#### 项目中间件实现

```go
// internal/interfaces/http/middleware/db_transaction.go
func DBTransaction(tx repository.Transactor, tenantCtx repository.TenantContextManager) gin.HandlerFunc {
    return func(c *gin.Context) {
        ctx := c.Request.Context()
        tenantID := GetTenantID(ctx)

        err := tx.WithTransaction(ctx, func(txCtx context.Context) error {
            // 在事务内设置租户上下文
            if tenantID != "" {
                if err := tenantCtx.SetTenant(txCtx, tenantID); err != nil {
                    return err
                }
            }

            c.Request = c.Request.WithContext(txCtx)
            c.Next()
            return nil
        })

        // 错误处理...
    }
}
```

**关键设计**：

- 使用 `set_config(..., is_local=TRUE)` 确保租户 ID 仅在当前事务内有效
- 请求级事务：每个 HTTP 请求绑定一个数据库事务
- 任何 SQL 查询都会自动应用 RLS 策略，无需在业务代码中手动添加 `WHERE tenant_id = ?`

#### RLS 策略示例

**直接关联租户的表**（如 projects）：

```sql
CREATE POLICY tenant_isolation_select ON projects FOR
SELECT USING (tenant_id = current_tenant_id());
```

**间接关联的表**（如 volumes 通过 project_id 关联）：

```sql
CREATE POLICY tenant_isolation_select ON volumes FOR
SELECT USING (
    project_id IN (
        SELECT id FROM projects
        WHERE tenant_id = current_tenant_id()
    )
);
```

### 1.4 安全防护

RLS 在数据库层面提供最后一道防线，即使应用层代码有 bug，租户 A 也无法访问租户 B 的数据。

**场景**：假设开发者在代码中忘记添加租户过滤

```go
// ❌ 不安全的代码（假设没有 RLS）
func GetProject(c *gin.Context) {
    projectID := c.Param("id")

    // 直接查询，可能返回其他租户的项目
    project, err := repo.GetByID(ctx, projectID)
    // 如果 projectID 属于租户 B，而当前用户是租户 A，
    // 没有 RLS 的话就会越权访问！
}
```

**RLS 自动拦截**：

```sql
-- 应用层 SQL（没有 WHERE tenant_id = ?）
SELECT * FROM projects WHERE id = 'proj_123';

-- RLS 自动添加的过滤条件（数据库层面）
SELECT * FROM projects
WHERE id = 'proj_123'
AND tenant_id = 'tenant_abc'  -- ← RLS 自动添加
```

---

## 二、双 Token 认证机制 (Dual-Token Authentication)

### 2.1 为什么需要双 Token？

传统的单 Token 方案：

```
用户登录 → 生成 Token（有效期 30 天）→ 客户端存储
```

问题：

- **安全风险**：Token 泄露后 30 天内都可被滥用
- **用户体验**：有效期太短需要频繁登录

双 Token 方案：

```
用户登录 → 生成双 Token
  ├─ Access Token（15 分钟）短期认证，频繁刷新
  └─ Refresh Token（7 天）长期认证，用于刷新 Access Token
```

优势：

- ✅ 安全性高：Access Token 泄露影响面小（15 分钟）
- ✅ 用户体验好：Refresh Token 保证 7 天内无需重新登录
- ✅ 可撤销性：Refresh Token 可以在服务端主动失效

### 2.2 Token 对比

| 特性         | Access Token                    | Refresh Token              |
| ------------ | ------------------------------- | -------------------------- |
| **有效期**   | 短（15 分钟）                   | 长（7 天）                 |
| **存储方式** | 内存 / LocalStorage             | HttpOnly Cookie            |
| **用途**     | 每次请求携带，用于身份认证      | 仅在刷新时使用             |
| **权限**     | 包含用户信息（tenant_id、role） | 只包含用于刷新的基本信息   |
| **泄露风险** | 低（15 分钟后自动失效）         | 中（可通过黑名单机制撤销） |

### 2.3 JWT 实现细节

#### Claims 结构

```go
// pkg/utils/jwt.go
type Claims struct {
    TenantID string `json:"tenant_id"`  // 多租户关键：租户 ID
    UserID   string `json:"user_id"`    // 用户 ID
    Role     string `json:"role"`       // 用户角色
    Type     string `json:"type"`       // Token 类型："access" 或 "refresh"
    jwt.RegisteredClaims
}
```

#### 生成 Token 对

```go
func (m *JWTManager) GenerateTokenPair(
    tenantID, userID, role string,
    accessTTL, refreshTTL time.Duration,
) (*TokenPair, error) {
    // 生成 Access Token（15 分钟）
    accessToken, err := m.GenerateToken(tenantID, userID, role, "access", accessTTL)
    if err != nil {
        return nil, err
    }

    // 生成 Refresh Token（7 天）
    refreshToken, err := m.GenerateToken(tenantID, userID, role, "refresh", refreshTTL)
    if err != nil {
        return nil, err
    }

    return &TokenPair{
        AccessToken:  accessToken,
        RefreshToken: refreshToken,
    }, nil
}
```

#### 认证流程

```mermaid
sequenceDiagram
    participant C as 客户端
    participant S as 服务器
    participant DB as 数据库

    C->>S: POST /v1/auth/login {tenant_id, email, password}
    S->>DB: 查询用户并验证密码
    DB-->>S: 返回用户信息
    S->>S: 生成 Access Token (15min) + Refresh Token (7天)
    S-->>C: 返回 Access Token + 设置 HttpOnly Cookie (Refresh Token)

    Note over C: 正常业务请求
    C->>S: GET /v1/projects<br/>Header: Authorization: Bearer <Access Token>
    S->>S: 验证 Access Token
    S-->>C: 返回业务数据

    Note over C: Access Token 过期后
    C->>S: POST /v1/auth/refresh<br/>Cookie: refresh_token=<Refresh Token>
    S->>S: 验证 Refresh Token
    S->>S: 生成新的 Access Token
    S-->>C: 返回新的 Access Token
```

#### 认证中间件

```go
// internal/interfaces/http/middleware/auth.go
func Auth(jwtManager *utils.JWTManager) gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"message": "missing token"})
            return
        }

        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        claims, err := jwtManager.ParseToken(tokenString)
        if err != nil {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"message": "invalid token"})
            return
        }

        // 将用户信息注入到 Context
        c.Set("tenant_id", claims.TenantID)
        c.Set("user_id", claims.UserID)
        c.Set("role", claims.Role)

        c.Next()
    }
}
```

#### Refresh Token 传输安全

**为什么用 HttpOnly Cookie？**

```go
// 登录成功后设置 Refresh Token
c.SetCookie(
    "refresh_token",           // Cookie 名称
    tokens.RefreshToken,        // Token 值
    int(7*24*time.Hour.Seconds()), // 有效期（7 天）
    "/v1/auth/refresh",         // 路径限制
    "",                         // Domain（空表示当前域名）
    false,                      // Secure（生产环境应设为 true，需要 HTTPS）
    true,                       // HttpOnly：禁止 JavaScript 访问，防止 XSS
)
```

| 存储方式        | 优点     | 缺点               | 安全性 |
| --------------- | -------- | ------------------ | ------ |
| LocalStorage    | 易于访问 | 易受 XSS 攻击      | ❌ 低  |
| Session Cookie  | 传统方式 | 易受 CSRF 攻击     | ⚠️ 中  |
| HttpOnly Cookie | 防 XSS   | 需要配合 CSRF 防护 | ✅ 高  |

### 2.4 Token 刷新流程

```go
// internal/interfaces/http/handler/auth.go
func (h *AuthHandler) RefreshToken(c *gin.Context) {
    // 1. 从 HttpOnly Cookie 获取 Refresh Token
    refreshToken, err := c.Cookie("refresh_token")
    if err != nil {
        dto.Unauthorized(c, "missing refresh token")
        return
    }

    // 2. 验证 Refresh Token
    claims, err := h.jwtManager.ParseToken(refreshToken)
    if err != nil {
        dto.Unauthorized(c, "invalid refresh token")
        return
    }

    // 3. 生成新的 Access Token（使用原用户信息）
    newAccessToken, err := h.jwtManager.GenerateToken(
        claims.TenantID,
        claims.UserID,
        claims.Role,
        "access",
        15*time.Minute,
    )
    if err != nil {
        dto.InternalError(c, "failed to generate access token")
        return
    }

    dto.Success(c, gin.H{
        "access_token": newAccessToken,
        "expires_in":   900, // 15 分钟 = 900 秒
    })
}
```

---

## 三、RBAC 权限控制 (Role-Based Access Control)

### 3.1 为什么需要 RBAC？

传统的权限控制：

```go
// ❌ 硬编码权限检查
if user.Email == "admin@example.com" {
    // 允许访问
}
```

问题：

- 代码分散，难以维护
- 权限变更需要修改代码
- 无法支持细粒度权限控制

RBAC（基于角色的访问控制）：

```go
// ✅ 基于角色的权限检查
if hasPermission(user.Role, "project:delete") {
    // 允许访问
}
```

优势：

- ✅ 权限集中管理
- ✅ 角色与权限解耦
- ✅ 易于扩展和维护

### 3.2 RBAC 模型层级

```mermaid
graph TD
    A[用户 User] -->|被分配| B[角色 Role]
    B -->|拥有| C[权限 Permission]
    C -->|作用于| D[资源 Resource]

    A --> A1[张三]
    A --> A2[李四]

    B --> B1[Admin]
    B --> B2[Member]
    B --> B3[Viewer]

    C --> C1[project:read]
    C --> C2[project:write]
    C --> C3[project:delete]
    C --> C4[admin:access]

    D --> D1[项目列表]
    D --> D2[用户管理]

    A1 --> B1
    A2 --> B2

    B1 --> C1
    B1 --> C2
    B1 --> C3
    B1 --> C4

    B2 --> C1
    B2 --> C2

    B3 --> C1
```

### 3.3 权限定义

```go
// internal/interfaces/http/middleware/rbac.go
const (
    // 项目权限
    PermProjectRead     Permission = "project:read"      // 查看项目
    PermProjectWrite    Permission = "project:write"     // 修改项目
    PermProjectDelete   Permission = "project:delete"    // 删除项目

    // 章节生成权限
    PermChapterGenerate Permission = "chapter:generate"   // 生成章节

    // 管理员权限
    PermAdminAccess     Permission = "admin:access"     // 管理后台访问
)
```

### 3.4 角色定义与权限映射

```go
// rolePermissions 角色-权限映射表
var rolePermissions = map[entity.UserRole][]Permission{
    entity.UserRoleAdmin: {
        PermProjectRead,
        PermProjectWrite,
        PermProjectDelete,
        PermChapterGenerate,
        PermAdminAccess,  // 仅 Admin 有
    },
    entity.UserRoleMember: {
        PermProjectRead,
        PermProjectWrite,
        PermChapterGenerate,
        // 没有 ProjectDelete 和 AdminAccess
    },
    entity.UserRoleViewer: {
        PermProjectRead,
        // 只有读取权限
    },
}
```

### 3.5 权限检查中间件

#### 方式一：检查权限

```go
// RequirePermission 检查用户是否具有指定权限
func RequirePermission(perm Permission) gin.HandlerFunc {
    return func(c *gin.Context) {
        roleStr := c.GetString("role")
        if roleStr == "" {
            abortForbidden(c, "missing role in context")
            return
        }

        role := entity.UserRole(roleStr)
        if !HasPermission(role, perm) {
            abortForbidden(c, "permission denied")
            return
        }

        c.Next()
    }
}
```

**使用示例**：

```go
// internal/interfaces/http/router/routes.go
authGroup := r.engine.Group("/v1")
authGroup.Use(middleware.Auth(jwtManager))

// 删除项目需要 project:delete 权限
authGroup.DELETE("/projects/:pid",
    middleware.RequirePermission(middleware.PermProjectDelete),
    handler.DeleteProject,
)
```

#### 方式二：检查角色

```go
// RequireRole 检查用户是否为指定角色之一
func RequireRole(roles ...entity.UserRole) gin.HandlerFunc {
    roleSet := make(map[entity.UserRole]bool)
    for _, r := range roles {
        roleSet[r] = true
    }

    return func(c *gin.Context) {
        roleStr := c.GetString("role")
        role := entity.UserRole(roleStr)

        if !roleSet[role] {
            abortForbidden(c, "role not allowed")
            return
        }

        c.Next()
    }
}
```

**使用示例**：

```go
// 只有 Admin 和 Member 可以访问
authGroup.POST("/projects",
    middleware.RequireRole(entity.UserRoleAdmin, entity.UserRoleMember),
    handler.CreateProject,
)
```

### 3.6 权限矩阵

| 操作                       | Admin | Member | Viewer |
| -------------------------- | ----- | ------ | ------ |
| 查看项目列表               | ✅    | ✅     | ✅     |
| 创建项目                   | ✅    | ✅     | ❌     |
| 修改项目                   | ✅    | ✅     | ❌     |
| 删除项目                   | ✅    | ❌     | ❌     |
| 生成章节                   | ✅    | ✅     | ❌     |
| 访问管理后台（用户管理等） | ✅    | ❌     | ❌     |

### 3.7 RBAC vs ABAC

| 特性         | RBAC（本项目）       | ABAC（基于属性的访问控制）         |
| ------------ | -------------------- | ---------------------------------- |
| **决策依据** | 角色 → 权限          | 用户属性 + 资源属性 + 环境条件     |
| **灵活度**   | 中等                 | 高                                 |
| **复杂度**   | 低                   | 高                                 |
| **适用场景** | 大部分企业应用       | 需要复杂规则的系统（如银行）       |
| **示例**     | "Admin 可以删除项目" | "项目所有者 或 周一至周五 9-18 点" |

**ABAC 示例**：

```go
// 复杂条件判断
if (user.Role == "admin") ||
   (user.ID == project.OwnerID) ||
   (time.Now().Hour() >= 9 && time.Now().Hour() < 18) {
    // 允许访问
}
```

---

## 四、三者的协同工作

### 4.1 中间件执行顺序

```go
// internal/interfaces/http/router/router.go
func (r *Router) setupMiddleware() {
    r.engine.Use(middleware.Recovery())           // 1. Panic 恢复
    r.engine.Use(middleware.CORS())                // 2. 跨域处理
    r.engine.Use(middleware.RequestID())          // 3. 生成 request_id
    r.engine.Use(middleware.Trace())              // 4. 生成 trace_id
    r.engine.Use(middleware.TraceContext())       // 5. 桥接：trace_id → logger
    r.engine.Use(middleware.DBTransaction(tx, tenantCtx)) // 6. 开启事务 + 设置租户上下文
    r.engine.Use(middleware.Auth(jwtManager))      // 7. JWT 认证
    r.engine.Use(middleware.RBACInjector())       // 8. 注入角色信息
}
```

### 4.2 完整请求流程

```mermaid
sequenceDiagram
    participant C as 客户端
    participant M1 as Auth中间件
    participant M2 as DBTransaction中间件
    participant M3 as RBAC中间件
    participant H as Handler
    participant DB as PostgreSQL

    C->>M1: GET /v1/projects<br/>Header: Authorization: Bearer <Token>
    M1->>M1: 验证 JWT Token
    M1->>M1: 提取 tenant_id, user_id, role
    M1->>M2: 注入 Context (tenant_id, user_id, role)

    M2->>DB: BEGIN TRANSACTION
    M2->>DB: SET app.current_tenant_id = 'tenant_abc'

    M2->>M3: 传递 Context (含 role)
    M3->>M3: 检查用户是否具有 project:read 权限

    alt 权限检查通过
        M3->>H: 调用 Handler
        H->>DB: SELECT * FROM projects WHERE ...
        Note over DB: RLS 自动添加：AND tenant_id = 'tenant_abc'
        DB-->>H: 返回租户 A 的项目数据
        H-->>M3: 返回项目列表
    else 权限检查失败
        M3-->>C: 返回 403 Forbidden
    end

    DB->>DB: COMMIT TRANSACTION
    M2-->>C: 返回响应
```

### 4.3 安全防护层级

```
┌─────────────────────────────────────────┐
│ 1. 应用层认证（JWT）                      │ ← 第一道防线：验证用户身份
├─────────────────────────────────────────┤
│ 2. 应用层授权（RBAC）                     │ ← 第二道防线：验证用户权限
├─────────────────────────────────────────┤
│ 3. 数据层隔离（RLS）                     │ ← 第三道防线：强制租户隔离
└─────────────────────────────────────────┘
```

### 4.4 实战场景：越权访问防护

**场景**：租户 A 的用户试图访问租户 B 的项目

```bash
# 假设租户 A 的用户（user_abc）请求访问租户 B 的项目（proj_xyz）
curl -X GET http://localhost:8080/v1/projects/proj_xyz \
  -H "Authorization: Bearer <user_abc_token>"
```

**多层防护机制**：

1. **JWT 验证**：Token 中的 `tenant_id` 为 `tenant_abc`
2. **RBAC 检查**：用户有 `project:read` 权限 ✅
3. **RLS 拦截**：数据库自动添加过滤条件

```sql
-- 实际执行的 SQL
SELECT * FROM projects
WHERE id = 'proj_xyz'
AND tenant_id = 'tenant_abc'  -- ← RLS 自动添加
-- 返回空结果（因为 proj_xyz 属于 tenant_xyz）
```

**结果**：返回 404 Not Found（而非越权访问成功）

---

## 五、配置与部署

### 5.1 配置文件

```yaml
# configs/config.yaml
auth:
  secret: "your-secret-key" # 生产环境必须使用环境变量
  issuer: "z-novel-ai-api"
  access_token_ttl: 15m # Access Token 有效期
  refresh_token_ttl: 168h # Refresh Token 有效期（7 天）

rbac:
  enabled: true # 是否启用 RBAC
  default_role: "viewer" # 新用户默认角色

tenant:
  allow_public_registration: false # 是否允许公开注册
  default_tenant_id: "default" # 默认租户 ID
```

### 5.2 环境变量

```bash
# .env
JWT_SECRET=prod-secret-key-change-me-in-production
FEATURES_RBAC_ENABLED=true
TENANT_ALLOW_PUBLIC_REGISTRATION=false
```

### 5.3 本地开发环境

```bash
# 1. 启动 PostgreSQL + Redis
docker compose up -d

# 2. 执行数据库迁移（包括 RLS 策略）
make migrate-up

# 3. 启动 API Gateway
JWT_SECRET="dev-secret" \
FEATURES_RBAC_ENABLED=true \
go run ./cmd/api-gateway
```

### 5.4 测试认证流程

```bash
# 1. 注册（需要租户 ID）
curl -X POST http://localhost:8080/v1/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "tenant_id": "default",
    "email": "test@example.com",
    "password": "password123",
    "name": "Test User"
  }'

# 响应：返回 access_token
{
  "access_token": "eyJhbGciOiJIUzI1NiIs...",
  "expires_in": 900,
  "user": {
    "id": "user_abc",
    "email": "test@example.com",
    "role": "viewer"  // 默认角色
  }
}

# 2. 使用 Access Token 访问受保护的资源
curl -X GET http://localhost:8080/v1/projects \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIs..."

# 3. Refresh Token 过期后刷新
curl -X POST http://localhost:8080/v1/auth/refresh \
  --cookie "refresh_token=eyJhbGciOiJIUzI1NiIs..."
```

---

## 六、最佳实践

### 6.1 多租户架构

✅ **推荐**：

```sql
-- RLS 策略覆盖所有业务表
ALTER TABLE projects ENABLE ROW LEVEL SECURITY;
ALTER TABLE volumes ENABLE ROW LEVEL SECURITY;
-- ... 其他表
```

❌ **避免**：

```sql
-- ❌ 在应用层手动添加租户过滤（容易遗漏）
func GetProject(c *gin.Context) {
    project, err := repo.GetByIDAndTenant(ctx, id, tenantID)
}
```

### 6.2 Token 管理

✅ **推荐**：

```go
// Access Token 存储在内存，自动管理
const token = response.access_token;
localStorage.setItem('token', token); // ⚠️ 虽然可以，但 HttpOnly Cookie 更安全

// Refresh Token 自动通过 HttpOnly Cookie 传递，前端无需处理
```

❌ **避免**：

```go
// ❌ 将敏感 Token 存储在 LocalStorage（易受 XSS 攻击）
localStorage.setItem('access_token', token);
localStorage.setItem('refresh_token', token);  // 危险！
```

### 6.3 RBAC 权限设计

✅ **推荐**：

```go
// 细粒度权限，读写分离
const (
    PermProjectRead  = "project:read"
    PermProjectWrite = "project:write"
    PermProjectDelete = "project:delete"
)
```

❌ **避免**：

```go
// ❌ 粗粒度权限，过度授权
const (
    PermProjectAdmin = "project:admin"  // 读写删除混在一起
)
```

### 6.4 安全配置

✅ **推荐**：

```go
// 生产环境启用 HttpOnly + Secure Cookie
c.SetCookie(
    "refresh_token",
    token,
    maxAge,
    "/v1/auth/refresh",
    "",
    true,   // Secure（需要 HTTPS）
    true,   // HttpOnly（防 XSS）
)
```

❌ **避免**：

```go
// ❌ 不启用 Secure 标志
c.SetCookie("refresh_token", token, maxAge, "/", "", false, true)
```

### 6.5 密码安全

✅ **推荐**：

```go
// 使用 bcrypt 加密密码
import "golang.org/x/crypto/bcrypt"

func (u *User) SetPassword(password string) error {
    hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return err
    }
    u.PasswordHash = string(hash)
    return nil
}
```

❌ **避免**：

```go
// ❌ 使用 MD5 或 SHA1
import "crypto/md5"

func (u *User) SetPassword(password string) {
    hash := md5.Sum([]byte(password))  // 不安全！
    u.PasswordHash = string(hash[:])
}
```

---

## 七、总结

多租户架构、双 Token 认证和 RBAC 权限控制可实现企业级安全防护：

1. **多租户架构**：通过 PostgreSQL RLS 实现数据库级别的租户隔离，即使应用层代码有 bug，也能保证数据不会泄露。

2. **双 Token 认证**：Access Token（短期）+ Refresh Token（长期）的方案平衡了安全性和用户体验，Refresh Token 通过 HttpOnly Cookie 传输防止 XSS 攻击。

3. **RBAC 权限控制**：基于角色的权限管理，将用户、角色、权限三者解耦，提供灵活且易于维护的访问控制机制。

这三者协同工作，从应用层认证、应用层授权、数据层隔离三个维度构建了完整的安全防护体系。

---

## 参考资料

- [PostgreSQL RLS 官方文档](https://www.postgresql.org/docs/current/ddl-rowsecurity.html)
- [JWT RFC 7519](https://tools.ietf.org/html/rfc7519)
- [OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org/)
- [RBAC vs ABAC](https://www.okta.com/identity-101/rbac-vs-abac/)
