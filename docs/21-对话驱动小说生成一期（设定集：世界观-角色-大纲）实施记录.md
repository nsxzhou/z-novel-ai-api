# 21 - 对话驱动小说生成系统技术规范

更新时间：2026-01-08

> 本文档是"对话驱动小说创作"功能的完整技术规范，整合了实施记录与演进路线图。涵盖从项目孵化、设定生成到版本管理的全链路设计。
>
> 说明：本文档已吸收并统一了 `docs/22-Eino设定生成工作流重构设计.md` 的关键设计要点与最新落地状态；`docs/22` 仅保留索引入口，避免重复维护与状态漂移。

---

## 1. 功能全景与模块状态

### 1.1 已完成模块 (Completed)

| 模块                           | 描述                                               | 核心入口                      |
| :----------------------------- | :------------------------------------------------- | :---------------------------- |
| **项目孵化 (ProjectCreation)** | 通过 4 阶段对话引导用户从模糊想法转化为正式项目    | `handler/project_creation.go` |
| **长期会话 (Conversation)**    | 支持在已有项目上进行多轮对话，切换任务迭代设定集   | `handler/conversation.go`     |
| **构件版本化 (Artifact)**      | 世界观/角色/大纲作为独立资产，支持多版本与一键回滚 | `handler/artifact.go`         |
| **一揽子生成 (Foundation)**    | 一次性生成完整设定包（Plan -> Validate -> Apply）  | `handler/foundation.go`       |
| **Token 配额治理**             | 租户级日配额预检与使用量统计                       | `quota/token_quota.go`        |
| **异步任务 (Jobs)**            | Redis Streams + Worker 执行长耗时生成              | `cmd/job-worker/main.go`      |
| **校验失败修复回路**           | Artifact Graph 内 Validate → Repair → Re-run（最多 2 次），减少不合规 JSON 直接失败 | `internal/application/story/artifact_generator.go` |
| **增量 Patch (JSON Patch)**    | 对 `novel_foundation/worldview` 支持 JSON Patch 输出，服务端应用后仍落库/返回完整 JSON | `internal/application/story/artifact_generator.go` |
| **上下文滚动摘要 (Redis)**     | 长会话自动压缩历史（summary + recent turns），注入 Prompt 降低 token 成本 | `internal/interfaces/http/handler/conversation.go` |

### 1.2 待完成模块 (In Progress / Planned)

| 模块                | 描述                                 | 优先级 |
| :------------------ | :----------------------------------- | :----- |
| **设定冲突扫描**    | 检测新生成内容与已有设定的矛盾       | P2     |
| **多分支创作**      | 支持同一节点的 A/B 版本对比          | P2     |
| **章节生成闭环**    | 补齐章节正文的同步/SSE/异步生成路径  | P1     |
| **检索服务 (RAG)**  | 实现向量检索与上下文召回             | P2     |
| **上下文自动摘要（LLM 版）** | 以 LLM/结构化压缩替代轻量滚动摘要，支持更长会话与更强语义保持 | P2     |
| **Patch 扩展（数组型构件）** | 扩展 `characters/outline` 的增量编辑（仅顶层 replace 或更稳健 JSON Pointer 方案） | P2     |

---

## 2. 核心能力路径详解

### 2.1 路径 A：项目孵化（从无到有）

**适用场景**：用户有模糊想法，通过对话逐步明确立项。

**API 入口**：

- `POST /v1/project-creation-sessions`: 创建孵化会话。
- `POST /v1/project-creation-sessions/:sid/messages`: 发送对话指令。

**技术流程**：

1. 用户进入"探索"阶段（discover），AI 通过引导性问题挖掘想法。
2. 进入"细化"阶段（narrow），AI 帮助用户确定题材、基调。
3. 进入"草稿"阶段（draft），AI 生成标题与简介。
4. 用户明确确认后，系统自动创建 Project 并关联长期会话。

**实现文件**：

- `internal/interfaces/http/handler/project_creation.go`
- `internal/application/story/project_creation_generator.go`
- `internal/domain/entity/project_creation.go`

---

### 2.2 路径 B：设定迭代（长期会话驱动）

**适用场景**：在已有项目基础上，通过对话反复打磨设定。

**API 入口**：

- `POST /v1/projects/:pid/sessions`: 创建长期会话。
- `POST /v1/projects/:pid/sessions/:sid/messages`: 发送指令并指定任务类型。
- `POST /v1/projects/:pid/artifacts/:aid/rollback`: 回滚到历史版本。

**任务类型（Task）**：

- `novel_foundation`: 小说基底（标题 + 简介）。
- `worldview`: 世界观设定。
- `characters`: 角色与关系网络。
- `outline`: 卷章大纲。

**技术流程**：

1. 系统加载"当前激活版本"的所有构件作为 AI 的背景上下文。
2. AI 结合用户指令产出新版本的完整 JSON。
3. 系统通过 `ai_key` 精准映射，将新版本入库。
4. 用户不满意可回滚到任意历史版本。

**实现文件**：

- `internal/interfaces/http/handler/conversation.go`
- `internal/application/story/artifact_generator.go`
- `internal/interfaces/http/handler/artifact.go`

---

### 2.3 路径 C：一揽子生成（Foundation 初始化）

**适用场景**：项目冷启动，一次性生成全量设定包。

**API 入口**：

- `POST /v1/projects/:pid/foundation/preview`: 同步生成 Plan。
- `GET|POST /v1/projects/:pid/foundation/stream`: SSE 流式生成。
- `POST /v1/projects/:pid/foundation/generate`: 异步生成（返回 Job ID）。
- `POST /v1/projects/:pid/foundation/apply`: 将 Plan 落库。

**实现文件**：

- `internal/interfaces/http/handler/foundation.go`
- `internal/application/story/foundation_generator.go`
- `internal/application/story/foundation_apply.go`

---

## 3. 技术架构关键选型

### 3.1 "项目创建会话"为何使用独立表？

- **数据解耦**：孵化期的草稿数据与正式项目资产物理隔离。
- **外键纯粹性**：正式会话表 `conversation_sessions.project_id` 保持 `NOT NULL` 约束。
- **清理便捷**：可按策略定期清理未完成的孵化草稿。

### 3.2 为何采用"全量快照"而非"局部 Patch"？

- **LLM 稳定性**：模型对全量 JSON 的理解和产出质量远高于 Patch/Diff 语法。
- **回滚极速**：仅需一次 `active_version_id` 指针更新。
- **调试友好**：每个版本都是完整可读的状态。

### 3.3 `ai_key` 稳定映射策略

- 解决问题：AI 输出顺序不稳定导致的数据错位。
- 方案：所有构件（Entity/Volume/Chapter）引入 `ai_key` 字段，后端按 Key 精准 Upsert。

---

## 4. 落库规则与校验约束

### 4.1 Plan 校验（必须做）

- **Key 唯一性**：`entities[].key`, `volumes[].key`, `chapters[].key` 不得重复。
- **引用完整性**：`relations[].source_key/target_key` 必须存在于 `entities[].key`。
- **枚举合法性**：`entity.type`, `entity.importance`, `relation.relation_type` 必须为预定义值。
- **长度限制**：`title/name` <= 255 字符，`outline/description` 做合理上限。

### 4.2 Apply 策略（幂等 Upsert）

- **Entities**：按 `(project_id, ai_key)` 做 Upsert。
- **Relations**：按 `(project_id, source_id, target_id, relation_type)` 去重更新。
- **Volumes/Chapters**：按 `ai_key` 匹配后重排 `seq_num`。

---

## 5. 后续路线图 (Roadmap)

### 第一阶段：精细化编辑 (Milestone 3)

- [x] **校验失败修复回路**：Artifact Graph 内 Validate → Repair → Re-run（最多 2 次）。
- [x] **增量 Patch 模式**：`novel_foundation/worldview` 支持 AI 输出 `JSON Patch`（仅顶层字段），服务端应用后仍输出完整 JSON。
- [x] **上下文滚动摘要**：使用 Redis 维护 summary + recent turns，超过阈值自动压缩历史并注入 Prompt。

### 第二阶段：质量实验室 (Milestone 4)

- [ ] **设定冲突扫描**：检测新生成内容与已有设定的矛盾并警告。
- [ ] **多分支创作**：支持同一节点的 A/B 版本并行与对比。

### 第三阶段：内容生成闭环 (Milestone 5)

- [ ] **章节生成**：补齐章节正文的同步/SSE/异步路径。
- [ ] **检索闭环**：实现 Milvus 向量检索与上下文召回。

---

## 附录：核心 API 索引

| 功能         | 入口                                               | 状态    |
| :----------- | :------------------------------------------------- | :------ |
| 对话式立项   | `POST /v1/project-creation-sessions`               | ✅ 就绪 |
| 发送孵化指令 | `POST /v1/project-creation-sessions/:sid/messages` | ✅ 就绪 |
| 创建长期会话 | `POST /v1/projects/:pid/sessions`                  | ✅ 就绪 |
| 发送任务指令 | `POST /v1/projects/:pid/sessions/:sid/messages`    | ✅ 就绪 |
| 构件回滚     | `POST /v1/projects/:pid/artifacts/:aid/rollback`   | ✅ 就绪 |
| 预览生成     | `POST /v1/projects/:pid/foundation/preview`        | ✅ 就绪 |
| 落库应用     | `POST /v1/projects/:pid/foundation/apply`          | ✅ 就绪 |

---

## 6. Eino 设定生成工作流（合并自文档 22）

本节将 `docs/22-Eino设定生成工作流重构设计.md` 合并进本文档，作为**唯一权威版本**；`docs/22` 仅保留索引，避免重复维护与状态漂移。

### 6.1 背景与现状

当前项目仅使用 Eino 的 OpenAI 适配器（`eino-ext/components/model/openai`）作为 LLM 调用封装，业务侧历史上以“手写 prompt + 手写解析/校验/降级”为主：

- LLM 工厂：`internal/infrastructure/llm/eino_factory.go`
- 设定生成：
  - `internal/application/story/foundation_generator.go`
  - `internal/application/story/artifact_generator.go`
  - `internal/application/story/project_creation_generator.go`

主要痛点：

1) Prompt 分散，缺少统一版本管理与复用。
2) 分支/回路（降级、校验失败重试、工具调用）靠业务代码 if/for，难以维护扩展。
3) 无 ToolCalling：上下文只能“全量塞入”，项目越大 token 成本越高。
4) 可观测性缺少组件级标准指标：无法按 node/model/tool 分析耗时与 token。

### 6.2 设计目标与边界（KISS / YAGNI）

#### 6.2.1 目标（本次落地）

1) **ChatTemplate 统一 Prompt 管理**：集中化、可版本化（go:embed）。
2) **Chain 重构主路径**：Prompt → LLM → Parse → Validate → Normalize。
3) **Graph 承载复杂流程**：分支、回路、工具调用（ReAct）等。
4) **ToolCalling 自主检索**：按需获取当前设定（世界观/角色/大纲/当前构件）。
5) **Eino Callback 增强可观测性**：统一 metrics/tracing/logs。
6) **项目孵化确定性确认门控**：服务端基于用户输入与阶段做强约束，避免模型幻觉触发创建。

#### 6.2.2 非目标（明确不做）

- 不改变现有 HTTP API 与 DB schema。
- 不一次性接入完整 RAG（检索服务当前仍为占位实现）；工具调用先基于“系统已拿到的设定快照”。

### 6.3 总体架构

#### 6.3.1 分层与代码组织

- Prompt 管理：`internal/workflow/prompt`（go:embed）
- 工作流编排（一期落地以“兼容现有入口”为优先）：
  - 当前 Chain/Graph 仍内嵌在 `internal/application/story/*_generator.go`，对外 API 不变
  - 后续可再抽离到 `internal/workflow/story/setting`（非阻塞）
- 可观测性：`internal/observability/eino`（全局 callbacks 初始化）

#### 6.3.2 基础设施与兼容性

- `EinoFactory` 统一提供 `model.BaseChatModel`，可按需断言为 `model.ToolCallingChatModel`（支持 ToolCalling）。
- 现有 handlers/job-worker 不改对外行为；内部调用 workflow 层实现。

### 6.4 Prompt 管理：ChatTemplate + go:embed

#### 6.4.1 方案

- Prompt 以“PromptID + 版本号”命名：
  - `foundation_plan_v1`
  - `artifact_v2`（全量输出）
  - `artifact_patch_v1`（JSON Patch 输出）
  - `project_creation_v1`
- Prompt 文件：`internal/workflow/prompt/templates/*.txt`，通过 `go:embed` 内嵌进二进制。
- `PromptRegistry`：`internal/workflow/prompt/registry.go`，对外提供 `ChatTemplate(id)`。

#### 6.4.2 好处

- Prompt 统一入口，便于审计、回滚与复用。
- 版本化可控，避免线上 prompt 漂移。

### 6.5 Chain：主路径流水线

#### 6.5.1 统一流水线（Foundation / ProjectCreation）

以 Foundation 为例（ProjectCreation 同理）：

1) BuildVars：将输入组装为模板变量（附件块、项目字段等）
2) ChatTemplate.Format：生成 messages
3) LLM.Generate：调用模型（优先 json_schema；不支持则降级 prompt-only）
4) Parse：抽取 JSON 对象
5) Validate / Normalize：强校验后输出标准 JSON + meta

#### 6.5.2 原则

- 单一职责：每个节点只做一件事。
- DRY：降级策略、meta 提取复用为通用函数/节点。

### 6.6 Graph：复杂分支与回路（Artifact：ToolCalling + Repair + Patch）

#### 6.6.1 ReAct 回路（工具调用 + 修复）

```mermaid
flowchart TD
  start([Input]) --> init[InitState + Template]
  init --> model[LLM.Generate (ToolCalling)]
  model -->|has tool_calls| tools[ToolsNode.Invoke]
  tools --> model
  model -->|no tool_calls| validate[Parse + Validate]
  validate -->|invalid| repair[Repair Prompt]
  repair --> model
  validate -->|valid| finalize[Normalize + Output]
  finalize --> end([Output])
```

#### 6.6.2 工具集（一期，默认开启）

- `artifact_get_active(type)`：返回指定类型的当前激活设定 JSON（来自系统已有快照）
- `artifact_search(query, type?, top_k?)`：在设定 JSON 中做关键词检索（一期为字符串匹配，后续可升级为 RAG）
- `project_get_brief()`：返回项目标题/简介/当前任务类型等摘要信息

约束：

- 工具只读，不接收 tenant/project 参数（由服务端上下文注入）。
- 设定最大步数/最大工具轮次，避免死循环与成本失控。
- 对不支持 ToolCalling 的 provider 自动降级到“无工具”的一次性生成。

#### 6.6.3 增量 Patch（JSON Patch）

- 仅对对象形态更稳定的 `novel_foundation/worldview` 启用（且必须存在当前版本 JSON）。
- 模型输出 `JSON Patch`（RFC 6902）数组，服务端应用后仍落库/返回**完整 JSON**，对外 API 字段不变。
- 限制：
  - `op` 仅允许：`add`/`replace`
  - `path` 仅允许顶层字段白名单（避免数组型 JSON Pointer 的高脆弱性）
  - Patch 模式修复耗尽后自动回退到“全量输出”再尝试一次，降低失败率

#### 6.6.4 上下文滚动摘要（Redis）

- Rolling Context：`internal/application/story/rolling_context.go`
- 注入点：`internal/interfaces/http/handler/conversation.go`
- 机制：按 `(tenant, project, session, task)` 在 Redis 维护 `summary + recent_user_turns`；超过阈值自动压缩历史并注入 prompt，降低 token 成本。
- 当前实现为“轻量滚动压缩”（不额外调用 LLM）；后续可在不改 API/DB 的前提下升级为 LLM/结构化摘要。

### 6.7 Callback：可观测性增强

#### 6.7.1 初始化方式

在各进程启动时（api-gateway / job-worker）注册全局回调：

- `callbacks.AppendGlobalHandlers(...)`

#### 6.7.2 指标建议

- `llm_requests_total{workflow,provider,model,success}`
- `llm_latency_ms_bucket{workflow,provider,model}`
- `llm_tokens_prompt_total{provider,model}`
- `llm_tokens_completion_total{provider,model}`
- `tool_calls_total{tool,success}`
- `tool_latency_ms_bucket{tool}`

约束：

- 不记录 prompt 原文；只记录长度/hash、token、耗时、错误码等元信息。

### 6.8 项目孵化：确定性确认门控

问题：模型可能在未确认时输出 `create_project`，导致误创建。

方案：服务端增加确定性门控：

1) 必须处于 `confirm` 阶段（会话状态机约束）
2) 必须从用户输入中检测到明确确认意图（否定词优先拦截）
3) 否则即使模型输出 `create_project` 也不执行创建，改为继续要求用户确认

### 6.9 实施路线（按风险递进）

#### Phase 1（低风险：立即收益）

- ✅ PromptRegistry + ChatTemplate 落地（go:embed）
- ✅ Foundation / ProjectCreation：Chain 重构 Generate 主路径
- ✅ 全局 Callback 初始化与基础 metrics
- ✅ ProjectCreation 确定性确认门控

#### Phase 2（中风险：质量提升）

- ✅ Artifact：Graph + ToolCalling ReAct 回路（不支持 tools 的 provider 自动降级）
- ✅ 工具一期：get_active / search / get_brief

#### Phase 3（高收益：规模化）

- ✅ 校验失败修复回路（Validate → Repair → Re-run，最多 2 次）
- ✅ 上下文滚动摘要（Redis，轻量滚动压缩；后续可升级为 LLM/结构化摘要）
- ✅ 增量 Patch 模式（JSON Patch）：先支持 `novel_foundation/worldview` 的顶层字段（add/replace + path 白名单）
- ⏳ 逐步把“全量上下文塞入”替换为“按需工具获取 + 自动摘要”（继续演进：更强语义摘要与结构化片段）
- ⏳ 检索服务（RAG）落地后，将 `artifact_search` 升级为向量召回 + 结构化片段返回

### 6.10 验收标准

- 兼容：现有 API 行为与字段不变（除项目孵化误创建被拦截属于安全修复）。
- 可观测：能看到 LLM 调用次数、耗时、token、工具调用次数与耗时。
- 可维护：Prompt 统一管理，可明确定位到 PromptID 与版本。

### 6.11 当前落地状态（2026-01-08）

#### 6.11.1 已完成

- ✅ PromptRegistry（go:embed）：`internal/workflow/prompt/registry.go` + `internal/workflow/prompt/templates/*.txt`（含 `artifact_v2` / `artifact_patch_v1`）
- ✅ Foundation（Chain）：`internal/application/story/foundation_generator.go`
- ✅ ProjectCreation（Chain）：`internal/application/story/project_creation_generator.go`
- ✅ Artifact（Graph + ToolCalling + Repair + Patch）：`internal/application/story/artifact_generator.go`
- ✅ 工具一期（只读）：`internal/application/story/artifact_tools.go`
- ✅ 上下文滚动摘要（Redis）：`internal/application/story/rolling_context.go` + `internal/interfaces/http/handler/conversation.go`
- ✅ Eino 可观测性（全局 callbacks）：`internal/observability/eino/*`
  - 初始化入口：`cmd/api-gateway/main.go`、`cmd/job-worker/main.go`
- ✅ ProjectCreation 确定性确认门控：`internal/interfaces/http/handler/project_creation.go`
- ✅ `EinoFactory` 输出类型升级为 `model.BaseChatModel`（支持 ToolCalling）：`internal/infrastructure/llm/eino_factory.go`

#### 6.11.2 待完成（下一步）

- ⏳ “上下文自动摘要（LLM/结构化）”：在不改 API/DB 的前提下，用更强语义压缩替代轻量滚动压缩，与 ToolCalling 结合进一步降 token。
- ⏳ Patch 扩展：`characters/outline` 的增量编辑策略（仅顶层 replace 或更稳健 JSON Pointer/patch 方案）。
- ⏳ `artifact_search` 从“字符串包含”演进为“结构化定位 + RAG 召回”（取决于检索服务落地）。
- ⏳ 进一步分层：将 Chain/Graph 从 `internal/application/story` 抽离到 `internal/workflow/story/setting`（不影响功能，但提升结构清晰度）。

### 6.12 本地验证

在沙箱环境下建议显式指定 `GOCACHE` 到工作区：

```bash
GOCACHE="$(pwd)/.gocache" go test ./...
```
